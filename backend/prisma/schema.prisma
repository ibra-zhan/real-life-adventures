// SideQuest Database Schema
// This schema defines all the data models for the SideQuest gamification platform

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// Enums
enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum QuestDifficulty {
  EASY
  MEDIUM
  HARD
  EPIC
}

enum QuestStatus {
  DRAFT
  AVAILABLE
  ACTIVE
  COMPLETED
  EXPIRED
  ARCHIVED
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
}

enum SubmissionType {
  PHOTO
  VIDEO
  TEXT
  CHECKLIST
}

enum BadgeType {
  STREAK
  COMPLETION
  SOCIAL
  SPECIAL
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum NotificationType {
  STREAK_REMINDER
  CHALLENGE_INVITE
  BADGE_UNLOCKED
  QUEST_AVAILABLE
  FRIEND_REQUEST
  COMMENT
  LIKE
  QUEST_APPROVED
  QUEST_REJECTED
}

enum ChallengeStatus {
  UPCOMING
  ACTIVE
  COMPLETED
  CANCELLED
}

// User Management
model User {
  id                String    @id @default(cuid())
  email             String    @unique
  username          String    @unique
  passwordHash      String
  avatar            String?
  firstName         String?
  lastName          String?
  bio               String?
  location          String?
  timezone          String?
  
  // Gamification
  level             Int       @default(1)
  xp                Int       @default(0)
  totalPoints       Int       @default(0)
  currentStreak     Int       @default(0)
  longestStreak     Int       @default(0)
  
  // Account Status
  role              UserRole  @default(USER)
  isActive          Boolean   @default(true)
  emailVerified     Boolean   @default(false)
  emailVerificationToken String?
  passwordResetToken String?
  passwordResetExpires DateTime?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  lastActiveAt      DateTime  @default(now())
  deletedAt         DateTime?
  
  // Relationships
  preferences       UserPreferences?
  sessions          UserSession[]
  questsCreated     Quest[]
  submissions       Submission[]
  userBadges        UserBadge[]
  challengesJoined  ChallengeParticipant[]
  notifications     Notification[]
  friendsInitiated  Friendship[] @relation("FriendshipInitiator")
  friendsReceived   Friendship[] @relation("FriendshipReceiver")
  comments          Comment[]
  likes             Like[]
  reports           Report[]
  xpLogs            XPLog[]
  
  @@map("users")
}

model UserPreferences {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Notification Preferences
  emailNotifications      Boolean @default(true)
  pushNotifications       Boolean @default(true)
  streakReminders         Boolean @default(true)
  newQuestNotifications   Boolean @default(true)
  challengeNotifications  Boolean @default(true)
  badgeNotifications      Boolean @default(true)
  socialNotifications     Boolean @default(true)
  
  // Privacy Preferences
  profileVisibility       String  @default("public") // public, friends, private
  shareCompletions        Boolean @default(true)
  showLocation            Boolean @default(false)
  showStreak              Boolean @default(true)
  showBadges              Boolean @default(true)
  
  // Quest Preferences
  preferredCategories     Json     // JSON array of category names
  preferredDifficulty     Json     // JSON array of preferred difficulties
  timeAvailablePerDay     Int      @default(30) // minutes per day
  autoAcceptFriendRequests Boolean @default(false)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@map("user_preferences")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken String   @unique
  deviceInfo   String?
  ipAddress    String?
  userAgent    String?
  expiresAt    DateTime
  createdAt    DateTime @default(now())
  
  @@map("user_sessions")
}

// Quest System
model QuestCategory {
  id          String @id @default(cuid())
  name        String @unique
  description String?
  icon        String?
  color       String?
  isActive    Boolean @default(true)
  sortOrder   Int     @default(0)
  
  quests      Quest[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("quest_categories")
}

model Quest {
  id                String          @id @default(cuid())
  title             String
  description       String
  shortDescription  String
  instructions      String?
  
  // Classification
  categoryId        String
  category          QuestCategory   @relation(fields: [categoryId], references: [id])
  difficulty        QuestDifficulty
  tags              Json            // JSON array of tags
  
  // Requirements & Rewards
  requirements      Json            // JSON array of requirement strings
  points            Int
  estimatedTime     Int             // minutes
  submissionTypes   Json            // JSON array of submission types
  
  // Status & Metadata
  status            QuestStatus     @default(DRAFT)
  isFeatured        Boolean         @default(false)
  isEpic            Boolean         @default(false)
  
  // Location Requirements
  locationRequired  Boolean         @default(false)
  locationType      String?         // indoor, outdoor, specific
  specificLocation  String?         // JSON object with location data
  
  // Social Settings
  allowSharing      Boolean         @default(true)
  encourageSharing  Boolean         @default(false)
  
  // Media
  imageUrl          String?
  videoUrl          String?
  
  // Creation & Moderation
  createdBy         String?         // User ID if user-generated
  creator           User?           @relation(fields: [createdBy], references: [id])
  moderatedBy       String?         // Admin/Moderator ID
  moderatedAt       DateTime?
  rejectionReason   String?
  
  // Stats
  completionCount   Int             @default(0)
  averageRating     Float?
  ratingCount       Int             @default(0)
  
  // Timestamps
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  publishedAt       DateTime?
  expiresAt         DateTime?
  
  // Relationships
  submissions       Submission[]
  challengeQuests   ChallengeQuest[]
  badgeRequirements BadgeRequirement[]
  
  @@map("quests")
}

// Submission System
model Submission {
  id              String           @id @default(cuid())
  questId         String
  quest           Quest            @relation(fields: [questId], references: [id])
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  
  type            SubmissionType
  status          SubmissionStatus @default(PENDING)
  
  // Content
  caption         String
  textContent     String?
  mediaUrls       Json?            // JSON array of media URLs
  checklistData   Json?            // JSON object for checklist submissions
  
  // Location (optional)
  latitude        Float?
  longitude       Float?
  address         String?
  
  // Privacy
  privacy         String           @default("public") // public, friends, private
  
  // Moderation
  approvedBy      String?
  approvedAt      DateTime?
  rejectionReason String?
  moderationFlags Json?            // JSON array of flag reasons
  flaggedAt       DateTime?
  flaggedBy       String?
  
  // Engagement
  likes           Like[]
  comments        Comment[]
  reports         Report[]
  
  // Timestamps
  submittedAt     DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  
  @@map("submissions")
}

// Gamification System
model Badge {
  id           String      @id @default(cuid())
  name         String      @unique
  description  String
  icon         String
  type         BadgeType
  rarity       BadgeRarity
  
  // Requirements
  requirements BadgeRequirement[]
  
  // Stats
  unlockedCount Int        @default(0)
  
  // Status
  isActive     Boolean     @default(true)
  
  // Timestamps
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  // Relationships
  userBadges   UserBadge[]
  challengeRewards ChallengeReward[]
  
  @@map("badges")
}

model BadgeRequirement {
  id           String @id @default(cuid())
  badgeId      String
  badge        Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  // Requirement Type
  type         String // quest_count, streak, category, points, level, social, special
  value        Int
  category     String? // For category-specific requirements
  questId      String? // For quest-specific requirements
  quest        Quest?  @relation(fields: [questId], references: [id])
  
  @@map("badge_requirements")
}

model UserBadge {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId     String
  badge       Badge    @relation(fields: [badgeId], references: [id])
  
  unlockedAt  DateTime @default(now())
  progress    Json?    // JSON object for tracking progress
  
  @@unique([userId, badgeId])
  @@map("user_badges")
}

model XPLog {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  amount      Int
  source      String   // quest_completion, streak_bonus, challenge_bonus, etc.
  sourceId    String?  // ID of the quest, challenge, etc.
  description String?
  
  createdAt   DateTime @default(now())
  
  @@map("xp_logs")
}

// Challenge System
model Challenge {
  id              String              @id @default(cuid())
  title           String
  description     String
  theme           String
  rules           String?
  prizesDescription String?
  
  // Timing
  startDate       DateTime
  endDate         DateTime
  status          ChallengeStatus     @default(UPCOMING)
  
  // Participation
  maxParticipants Int?
  currentParticipants Int           @default(0)
  
  // Media
  imageUrl        String?
  bannerUrl       String?
  
  // Creation
  createdBy       String
  
  // Timestamps
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  // Relationships
  participants    ChallengeParticipant[]
  quests          ChallengeQuest[]
  rewards         ChallengeReward[]
  leaderboard     ChallengeLeaderboard[]
  
  @@map("challenges")
}

model ChallengeParticipant {
  id            String    @id @default(cuid())
  challengeId   String
  challenge     Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  joinedAt      DateTime  @default(now())
  completedAt   DateTime?
  score         Int       @default(0)
  
  @@unique([challengeId, userId])
  @@map("challenge_participants")
}

model ChallengeQuest {
  id            String    @id @default(cuid())
  challengeId   String
  challenge     Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  questId       String
  quest         Quest     @relation(fields: [questId], references: [id])
  
  pointMultiplier Float   @default(1.0)
  isRequired    Boolean   @default(false)
  
  @@unique([challengeId, questId])
  @@map("challenge_quests")
}

model ChallengeReward {
  id            String    @id @default(cuid())
  challengeId   String
  challenge     Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  badgeId       String
  badge         Badge     @relation(fields: [badgeId], references: [id])
  
  requirement   String    // first_place, top_10, completion, etc.
  
  @@map("challenge_rewards")
}

model ChallengeLeaderboard {
  id            String    @id @default(cuid())
  challengeId   String
  challenge     Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  userId        String
  
  rank          Int
  score         Int
  completedQuests Int     @default(0)
  
  updatedAt     DateTime  @updatedAt
  
  @@unique([challengeId, userId])
  @@map("challenge_leaderboard")
}

// Social Features
model Friendship {
  id          String   @id @default(cuid())
  initiatorId String
  initiator   User     @relation("FriendshipInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  receiverId  String
  receiver    User     @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)
  
  status      String   @default("pending") // pending, accepted, blocked
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([initiatorId, receiverId])
  @@map("friendships")
}

model Comment {
  id           String   @id @default(cuid())
  submissionId String
  submission   Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  content      String
  parentId     String?  // For nested comments
  parent       Comment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies      Comment[] @relation("CommentReplies")
  
  likes        Like[]
  reports      Report[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("comments")
}

model Like {
  id           String      @id @default(cuid())
  userId       String
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Polymorphic relationship - can like submissions or comments
  submissionId String?
  submission   Submission? @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  commentId    String?
  comment      Comment?    @relation(fields: [commentId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime    @default(now())
  
  @@unique([userId, submissionId])
  @@unique([userId, commentId])
  @@map("likes")
}

model Report {
  id           String      @id @default(cuid())
  reporterId   String
  reporter     User        @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  
  // Polymorphic relationship - can report submissions or comments
  submissionId String?
  submission   Submission? @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  commentId    String?
  comment      Comment?    @relation(fields: [commentId], references: [id], onDelete: Cascade)
  
  reason       String
  description  String?
  status       String      @default("pending") // pending, reviewed, resolved, dismissed
  
  reviewedBy   String?
  reviewedAt   DateTime?
  resolution   String?
  
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  
  @@map("reports")
}

// Notification System
model Notification {
  id          String           @id @default(cuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type        NotificationType
  title       String
  message     String
  actionUrl   String?
  metadata    Json?            // JSON object for additional data
  
  read        Boolean          @default(false)
  readAt      DateTime?
  
  createdAt   DateTime         @default(now())
  expiresAt   DateTime?
  
  @@map("notifications")
}

// Analytics & Logging
model AnalyticsEvent {
  id          String   @id @default(cuid())
  userId      String?
  
  event       String   // quest_started, quest_completed, badge_unlocked, etc.
  category    String   // engagement, gamification, social, etc.
  properties  Json?    // JSON object with event properties
  
  sessionId   String?
  deviceInfo  String?
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime @default(now())
  
  @@map("analytics_events")
}

model SystemLog {
  id        String   @id @default(cuid())
  level     String   // error, warn, info, debug
  message   String
  category  String   // api, auth, database, etc.
  metadata  Json?    // JSON object with additional context
  
  userId    String?
  requestId String?
  
  createdAt DateTime @default(now())
  
  @@map("system_logs")
}

// Indexes for performance
// These will be created automatically by Prisma based on the relations
// Additional custom indexes can be added as needed